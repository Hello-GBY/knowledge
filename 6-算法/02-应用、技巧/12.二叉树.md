>初学递归的人排斥递归，大部分是出于对“函数调用自身”这种骚操作的不适应。但只要你能克服这种不适应，并且通过反复的演练去吸收这种解题方法，你就会发现递归真的是个好东西。因为通过使用递归，我们可以把原本复杂的东西，拆解成非常简单的、符合人类惯用脑回路的逻辑。

> 题目描述：给定一个二叉树，返回它的前序（先序）遍历序列。

>示例: 输入: [1,null,2,3]
1   
 \   
  2   
 /  
3 
输出: [1,2,3]
进阶: 递归算法很简单，你可以通过迭代算法完成吗？
 
> 右->左->根

> 合理地安排入栈和出栈的时机、使栈的出栈序列符合二叉树的前序遍历规则。

```
前序遍历的规则是，先遍历根结点、然后遍历左孩子、最后遍历右孩子——这正是我们所期望的出栈序列。按道理，入栈序列和出栈序列相反，我们似乎应该按照 右->左->根 这样的顺序将结点入栈。不过需要注意的是，我们遍历的起点就是根结点，难道我们要假装没看到这个根结点、一鼓作气找到最右侧结点之后才开始进行入栈操作吗？答案当然是否定的，我们的出入栈顺序应该是这样的：
```

```js
if(a.width > 0) {

}
```

# 思路
二叉树解题思路分两种：
  一种是递归的时候不需要返回值    遍历定义在全局之外
  一种是递归的时候需要有返回值    直接接收变量
  
如果单独抽出一个二叉树节点，它需要做什么事情？需要在什么时候（前/中/后序位置）做？其他的节点不用你操心，递归函数会帮你在所有节点上执行相同的操作。


第一种： 递归的时候不需要返回值
```js
// 记录最大深度
var res = 0;
// 记录遍历到的节点的深度
var depth = 0;

// 主函数
function maxDepth(root) {
    traverse(root);
    return res;
}

// 二叉树遍历框架
function traverse(root) {
    if (root == null) {
        return;
    }
    // 前序位置
    depth++;
    if (root.left == null && root.right == null) {
        // 到达叶子节点，更新最大深度
        res = Math.max(res, depth);
    }
    traverse(root.left);
    traverse(root.right);
    // 后序位置
    depth--;
}
```
解法二：
```js
var maxDepth = function(root) {
    if (root == null) {
        return 0;
    }
    // 利用定义，计算左右子树的最大深度
    var leftMax = maxDepth(root.left);
    var rightMax = maxDepth(root.right);
    // 整棵树的最大深度等于左右子树的最大深度取最大值，
    // 然后再加上根节点自己
    var res = Math.max(leftMax, rightMax) + 1;

    return res;
}
```
